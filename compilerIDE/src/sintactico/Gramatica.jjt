options{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  NODE_PREFIX = "AST";
}


PARSER_BEGIN(Gramatica)
package sintactico;
import jflexpackage.*;

public class Gramatica{
    public static void main(String [] args) throws ParseException {
        Gramatica analizador = new Gramatica(System.in);
        SimpleNode root = analizador.program();
        //root.dump("");
    }
}

PARSER_END(Gramatica)

/*Analizador léxico*/
//Saltar espacios
SKIP : {
    " " | "\t" | "\r" | "\n" 
}

TOKEN : {
    <PROGRAM: "program" >
    | < LBRACE : "{" >
    | < RBRACE : "}" >
    | < LBRACKET : "[" >
    | < RBRACKET : "]" >
    | < LPAREN : "(" >
    | < RPAREN : ")" >
    | < SEMICOLON : ";" >
    | < COMMA : "," >
    | < ASSIGN : "=" >
    | < OR : "or" >
    | < AND : "and" >
    | < EQ : "==" >
    | < NEQ : "!=" >
    | < LT : "<" >
    | < LTE : "<=" >
    | < GT : ">" >
    | < GTE : ">=" >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < ASTERISK : "*" >
    | < SLASH : "/" >
    | < NOT : "not" >
    | < IF : "if" >
    | < FI : "fi" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < DO : "do" >
    | < UNTIL : "until" >
    | < READ : "read" >
    | < WRITE : "write" >
    | < BREAK : "break" >
    | < INT : "int" >
    | < FLOAT : "float" >
    | < BOOL : "bool" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < THEN : "then" >
    | < ID : (["a"-"z", "A"-"Z"])+ >
    | < INTEGER : (["0"-"9"])+ >
    | < REAL : (["0"-"9"])+ "." (["0"-"9"])* > 
    
    
}

// when /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
SKIP : {
  "/*": IN_COMMENT
}

// when any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > SKIP : {
  < ~[] >
}

// when */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : {
  "*/": DEFAULT
}

SKIP :
{
    <"//" (~["\n"])* "\n">
}

SimpleNode program():{}{
<PROGRAM> lbrace() ((lista_decl())* (lista_sent())*) rbrace() <EOF>
{
    return jjtThis;
}
}



void lista_decl():{}{decl()}


void decl():{
    String type = "";
}{
    type = tipo() lista_id(type) semicolon()
}


String tipo():{
    String type = "";
}{
    type=intToken() {return type;}
    | type=floatToken(){return type;}  
    | type=boolToken(){return type;}

}


void lista_id(String type):{}{ 
    idDecl(type) ( comma() idDecl(type) )* 
}


void lista_sent():{}{ sent() ( sent() )* }
void sent():{}{sent_if() | sent_while() | sent_do() | sent_read() | sent_write() | bloque() | sent_assign() | breakToken()}
void sent_if():{
    SymbolNode tempVar;
}{ 
    ifToken() lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() then() bloque() (elseToken() bloque())* fi() 

}

void sent_while():{
    SymbolNode tempVar;
}{
    whileToken() lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() bloque()
}

void sent_do():{
    SymbolNode tempVar;
}{ 
    doToken() bloque() <UNTIL> lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() semicolon()
}

void sent_read():{}{ read() id() semicolon()}
void sent_write():{}{write() id() semicolon()}
void bloque():{}{ lbrace() lista_sent() rbrace()}


void sent_assign():{
    String identifier="";
    SymbolNode tempVar = null;
}{
    identifier=idAssign() assign() tempVar=exp_bool() semicolon() ({
        if(SymTable.Contains(identifier)){
            SymbolNode id = SymTable.GetIndex(identifier);
            if((id.type == tempVar.type) || (id.type =="float" && (tempVar.type == "float" || tempVar.type=="int"))){
                SymTable.UpdateIndex(identifier, tempVar);
                if(id.type =="float" && tempVar.type=="int"){
                    IDE.errores += "Warning: Pérdida de precisión. \n";
                }
            }else {//error, tipos de datos diferentes
                IDE.errores += "Error: El tipo de dato no es compatible. \n";
            }
        }else{IDE.errores += "Error: Var no declarada \n";} //error, variable no declarada
    })
}


SymbolNode exp_bool():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
}{ 
    acum1=comb() ( or() acum2=comb(){
                    acum3.value = ((Boolean) acum1.value).booleanValue() || ((Boolean) acum2.value).booleanValue() ? true : false;
                    acum3.type="bool";
                    return acum3;
                 } )* 
    {return acum1;}
}


SymbolNode comb():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
}{ 
    acum1=igualdad() ( and() acum2=igualdad(){
                      acum3.value = ((Boolean) acum1.value).booleanValue() && ((Boolean) acum2.value).booleanValue() ? true : false; 
                      acum3.type="bool";
                      return acum3;
                     } )* 
    {return acum1;}
}


SymbolNode igualdad():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
    String op = "";
}{ 
    acum1=rel() ( ( op=eq() | op=neq() ) acum2=rel(){
                    double numericValue1 = 0.0;
                    double numericValue2 = 0.0;

                    if (acum1.value instanceof Integer) {
                        numericValue1 = (int) acum1.value;
                    } else if (acum1.value instanceof Double) {
                        numericValue1 = (double) acum1.value;
                    }else numericValue1 = ((Boolean) acum1.value).booleanValue() == true ? 1 : 0;

                    if (acum2.value instanceof Integer) {
                        numericValue2 = (int) acum2.value;
                    } else if (acum2.value instanceof Double) {
                        numericValue2 = (double) acum2.value;
                    }else numericValue2 = ((Boolean) acum2.value).booleanValue() == true ? 1 : 0;

                    switch(op) {
                        case "==":
                            acum3.value = numericValue1 == numericValue2;
                            break;
                        case "!=":
                            acum3.value = numericValue1 != numericValue2;
                            break;
                    }
                    acum3.type = "bool";
                    return acum3;
                } )*
    {return acum1;}
}


SymbolNode rel():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("", null);
    String op = "";
}{ 
    acum1=expr() [op=op_rel() acum2=expr(){
                    double numericValue1 = 0.0;
                    double numericValue2 = 0.0;

                    if (acum1.value instanceof Integer) {
                        numericValue1 = (int) acum1.value;
                    } else if (acum1.value instanceof Double) {
                        numericValue1 = (double) acum1.value;
                    }

                    if (acum2.value instanceof Integer) {
                        numericValue2 = (int) acum2.value;
                    } else if (acum2.value instanceof Double) {
                        numericValue2 = (double) acum2.value;
                    }

                    switch(op) {
                        case "<":
                            acum3.value = numericValue1 < numericValue2;
                            break;
                        case "<=":
                            acum3.value = numericValue1 <= numericValue2;
                            break;
                        case ">":
                            acum3.value = numericValue1 > numericValue2;
                            break;
                        case ">=":
                            acum3.value = numericValue1 >= numericValue2;
                            break;
                    }
                    acum3.type="bool";
                    return acum3;
                 }]
    {return acum1;}
}

String op_rel():{
    String op ="";
}{op=lt(){return op;} | op=lte(){return op;} | op=gt(){return op;} | op=gte(){return op;}}



SymbolNode expr():{
    SymbolNode acum1 = null;
    SymbolNode acum2 = null;
}{ 
    acum1=term() ( ( plus() acum2=term() {
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        + (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    } )
                | ( minus() acum2=term(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        - (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());
                        
                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                 } ) 
                 )*
    {return acum1;} 
}


SymbolNode term():{
    SymbolNode acum1 = null;
    SymbolNode acum2 = null;
}{ 
    acum1=unario() ( ( asterisk() acum2=unario(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        * (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    }) 
                    | (slash() acum2=unario(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        / (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    })  
                   )* 
    {return acum1;}
}


SymbolNode unario():{
    SymbolNode acum1 = null;
}{
    not() unario() | minus() unario() | acum1=factor()
    {return acum1;}
}


SymbolNode factor():{
    SymbolNode acum1 = null;
}{
    lparen() exp_bool() rparen() {return acum1;}| acum1=id() {return acum1;}| acum1=integer() {return acum1;} | acum1=real() {return acum1;} | acum1=trueToken() {return acum1;} | acum1=falseToken()
    {return acum1;}
}

void lbrace():{}{
    <LBRACE>
}


public void rbrace():{} {
    <RBRACE>
}

public void lbracket():{} {
    <LBRACKET>
}

public void rbracket():{} {
    // Código de la función rbracket
    <RBRACKET>
}

public void lparen():{} {
    // Código de la función lparen
    <LPAREN>  
}

public void rparen():{} {
    // Código de la función rparen
<RPAREN>
}

public void semicolon():{} {
    // Código de la función semicolon
<SEMICOLON>
}

public void comma():{} {
    // Código de la función comma
<COMMA>
}

public void assign():{} {
    // Código de la función assign
<ASSIGN>
}

public void or():{} {
    // Código de la función or
<OR>
}

public void and():{} {
    // Código de la función and
<AND>
}

public String eq():{} {
<EQ>{return token.image;}
    // Código de la función eq
}

public String neq():{} {
<NEQ>{return token.image;}
    // Código de la función neq
}

public String lt():{} {
<LT>{return token.image;}
    // Código de la función lt
}

public String lte():{} {
<LTE>{return token.image;}
    // Código de la función lte
}

public String gt():{} {
<GT>{return token.image;}
    // Código de la función gt
}

public String gte():{} {
<GTE>{return token.image;}
    // Código de la función gte
}

public void plus():{} {
<PLUS> 
    // Código de la función plus
}

public void minus():{} {
<MINUS> 
    // Código de la función minus
}

public void asterisk():{} {
<ASTERISK>
    // Código de la función asterisk
}

public void slash():{} {
<SLASH>
    // Código de la función slash
}

public void not():{} {
<NOT>
    // Código de la función not
}

public void ifToken():{} {
<IF>
    // Código de la función ifToken
}

public void fi():{} {
<FI>
    // Código de la función fi
}

public void elseToken():{} {
<ELSE>
    // Código de la función elseToken
}

public void whileToken():{} {
<WHILE>
    // Código de la función whileToken
}

public void doToken():{} {
<DO>
    // Código de la función doToken
}

public void until():{} {
<UNTIL>
    // Código de la función until
}

public void read():{} {
<READ>
    // Código de la función read
}

public void write():{} {
<WRITE>
    // Código de la función write
}

public void breakToken():{} {
<BREAK>
    // Código de la función breakToken
}

public String intToken():{} {
<INT> {return token.image;}
    // Código de la función intToken
}

public String floatToken():{} {
<FLOAT> {return token.image;}
    // Código de la función floatToken
}

public String boolToken():{} {
<BOOL> {return token.image;}
    // Código de la función bool
}

public SymbolNode trueToken():{} {
<TRUE>{return new SymbolNode("bool", true);}
    // Código de la función trueToken  
}

public SymbolNode falseToken():{} {
<FALSE> {return new SymbolNode("bool", false);}
    // Código de la función falseToken
}

public void then():{} {
<THEN>
    // Código de la función then
}

public SymbolNode id():{} {
<ID>{return SymTable.GetIndex(token.image);}
    // Código de la función id
}

public void idDecl(String type):{}{
<ID>{SymTable.AddIndex(token.image, type);}
}

public String idAssign():{}{
<ID>{return token.image;}
}

public SymbolNode integer():{} {
<INTEGER> {return new SymbolNode("int", Integer.parseInt(token.image));}
    // Código de la función integer
}

public SymbolNode real():{} {
<REAL> {return new SymbolNode("float", Double.parseDouble(token.image));}
    // Código de la función real
}