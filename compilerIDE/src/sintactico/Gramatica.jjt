options{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  NODE_PREFIX = "AST";
}


PARSER_BEGIN(Gramatica)
package sintactico;
import jflexpackage.*;

public class Gramatica{
    public static void main(String [] args) throws ParseException {
        Gramatica analizador = new Gramatica(System.in);
        SimpleNode root = analizador.program();
        //root.dump("");
    }
}

PARSER_END(Gramatica)

/*Analizador léxico*/
//Saltar espacios
SKIP : {
    " " | "\t" | "\r" | "\n" 
}

TOKEN : {
    <PROGRAM: "program" >
    | < LBRACE : "{" >
    | < RBRACE : "}" >
    | < LBRACKET : "[" >
    | < RBRACKET : "]" >
    | < LPAREN : "(" >
    | < RPAREN : ")" >
    | < SEMICOLON : ";" >
    | < COMMA : "," >
    | < ASSIGN : "=" >
    | < OR : "or" >
    | < AND : "and" >
    | < EQ : "==" >
    | < NEQ : "!=" >
    | < LT : "<" >
    | < LTE : "<=" >
    | < GT : ">" >
    | < GTE : ">=" >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < ASTERISK : "*" >
    | < SLASH : "/" >
    | < NOT : "not" >
    | < IF : "if" >
    | < FI : "fi" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < DO : "do" >
    | < UNTIL : "until" >
    | < READ : "read" >
    | < WRITE : "write" >
    | < BREAK : "break" >
    | < INT : "int" >
    | < FLOAT : "float" >
    | < BOOL : "bool" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < THEN : "then" >
    | < ID : (["a"-"z", "A"-"Z"])+ >
    | < INTEGER : (["0"-"9"])+ >
    | < REAL : (["0"-"9"])+ "." (["0"-"9"])* > 
    
    
}

// when /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
SKIP : {
  "/*": IN_COMMENT
}

// when any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > SKIP : {
  < ~[] >
}

// when */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : {
  "*/": DEFAULT
}

SKIP :
{
    <"//" (~["\n"])* "\n">
}

SimpleNode program():{}{
<PROGRAM> lbrace() ((lista_decl())* (lista_sent())*) rbrace() <EOF>
{
    return jjtThis;
}
}



void lista_decl():{}{decl()}


void decl():{
    String type = "";
    //CMTC1
    jjtThis.value = "Declaracion";
}{
    type = tipo() lista_id(type) semicolon()
}


String tipo():{
    String type = "";
}{
    type=intToken() {return type;}
    | type=floatToken(){return type;}  
    | type=boolToken(){return type;}

}


void lista_id(String type):{}{ 
    idDecl(type) ( comma() idDecl(type) )* 
}


void lista_sent():{}{ sent() ( sent() )* }
void sent():{}{sent_if() | sent_while() | sent_do() | sent_read() | sent_write() | bloque() | sent_assign() | breakToken()}
void sent_if():{
    SymbolNode tempVar;
}{ 
    ifToken() lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() then() bloque() (elseToken() bloque())* fi() 

}

void sent_while():{
    SymbolNode tempVar;
}{
    whileToken() lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() bloque()
}

void sent_do():{
    SymbolNode tempVar;
}{ 
    doToken() bloque() until() lparen() tempVar=exp_bool(){ SymTable.AddTemporalIndex(tempVar); } rparen() semicolon()
}

void sent_read():{}{ read() id() semicolon()}
void sent_write():{}{write() id() semicolon()}
void bloque():{}{ lbrace() lista_sent() rbrace()}


void sent_assign():{
    String identifier="";
    SymbolNode tempVar = null;
    jjtThis.value = "Asignacion";
}{
    identifier=idAssign() assign() tempVar=exp_bool() semicolon() ({
        if(SymTable.Contains(identifier)){
            SymbolNode id = SymTable.GetIndex(identifier);
            if((id.type == tempVar.type) || (id.type =="float" && (tempVar.type == "float" || tempVar.type=="int"))){
                SymTable.UpdateIndex(identifier, tempVar);
                if(id.type =="float" && tempVar.type=="int"){
                    IDE.errores += "Warning: Pérdida de precisión. \n";
                }
            }else {//error, tipos de datos diferentes
                IDE.errores += "Error: El tipo de dato no es compatible. \n";
            }
        }else{IDE.errores += "Error: Var no declarada \n";} //error, variable no declarada
    })
}


SymbolNode exp_bool():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
}{ 
    acum1=comb() ( or() acum2=comb(){
                    acum3.value = ((Boolean) acum1.value).booleanValue() || ((Boolean) acum2.value).booleanValue() ? true : false;
                    acum3.type="bool";
                    return acum3;
                 } )* 
    {return acum1;}
}


SymbolNode comb():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
}{ 
    acum1=igualdad() ( and() acum2=igualdad(){
                      acum3.value = ((Boolean) acum1.value).booleanValue() && ((Boolean) acum2.value).booleanValue() ? true : false; 
                      acum3.type="bool";
                      return acum3;
                     } )* 
    {return acum1;}
}


SymbolNode igualdad():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("",null);
    String op = "";
}{ 
    acum1=rel() ( ( op=eq() | op=neq() ) acum2=rel(){
                    double numericValue1 = 0.0;
                    double numericValue2 = 0.0;

                    if (acum1.value instanceof Integer) {
                        numericValue1 = (int) acum1.value;
                    } else if (acum1.value instanceof Double) {
                        numericValue1 = (double) acum1.value;
                    }else numericValue1 = ((Boolean) acum1.value).booleanValue() == true ? 1 : 0;

                    if (acum2.value instanceof Integer) {
                        numericValue2 = (int) acum2.value;
                    } else if (acum2.value instanceof Double) {
                        numericValue2 = (double) acum2.value;
                    }else numericValue2 = ((Boolean) acum2.value).booleanValue() == true ? 1 : 0;

                    switch(op) {
                        case "==":
                            acum3.value = numericValue1 == numericValue2;
                            break;
                        case "!=":
                            acum3.value = numericValue1 != numericValue2;
                            break;
                    }
                    acum3.type = "bool";
                    return acum3;
                } )*
    {return acum1;}
}


SymbolNode rel():{
    SymbolNode acum1;
    SymbolNode acum2;
    SymbolNode acum3 = new SymbolNode("", null);
    String op = "";
}{ 
    acum1=expr() [op=op_rel() acum2=expr(){
                    double numericValue1 = 0.0;
                    double numericValue2 = 0.0;

                    if (acum1.value instanceof Integer) {
                        numericValue1 = (int) acum1.value;
                    } else if (acum1.value instanceof Double) {
                        numericValue1 = (double) acum1.value;
                    }

                    if (acum2.value instanceof Integer) {
                        numericValue2 = (int) acum2.value;
                    } else if (acum2.value instanceof Double) {
                        numericValue2 = (double) acum2.value;
                    }

                    switch(op) {
                        case "<":
                            acum3.value = numericValue1 < numericValue2;
                            break;
                        case "<=":
                            acum3.value = numericValue1 <= numericValue2;
                            break;
                        case ">":
                            acum3.value = numericValue1 > numericValue2;
                            break;
                        case ">=":
                            acum3.value = numericValue1 >= numericValue2;
                            break;
                    }
                    acum3.type="bool";
                    return acum3;
                 }]
    {return acum1;}
}

String op_rel():{
    String op ="";
}{op=lt(){return op;} | op=lte(){return op;} | op=gt(){return op;} | op=gte(){return op;}}



SymbolNode expr():{
    SymbolNode acum1 = null;
    SymbolNode acum2 = null;
}{ 
    acum1=term() ( ( plus() acum2=term() {
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        + (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    } )
                | ( minus() acum2=term(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        - (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());
                        
                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                 } ) 
                 )*
    {return acum1;} 
}


SymbolNode term():{
    SymbolNode acum1 = null;
    SymbolNode acum2 = null;
}{ 
    acum1=unario() ( ( asterisk() acum2=unario(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        * (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    }) 
                    | (slash() acum2=unario(){
                        acum1.value = (acum1.type == "float" ? ((Number) acum1.value).doubleValue() : ((Number) acum1.value).intValue())
                        / (acum2.type == "float" ? ((Number) acum2.value).doubleValue() : ((Number) acum2.value).intValue());

                        if(acum1.type == "float" || acum2.type == "float") acum1.type = "float";
                        else acum1.type = "int";
                    })  
                   )* 
    {return acum1;}
}


SymbolNode unario():{
    SymbolNode acum1 = null;
}{
    not() unario() | minus() unario() | acum1=factor()
    {return acum1;}
}


SymbolNode factor():{
    SymbolNode acum1 = null;
}{
    lparen() exp_bool() rparen() {return acum1;}| acum1=id() {return acum1;}| acum1=integer() {return acum1;} | acum1=real() {return acum1;} | acum1=trueToken() {return acum1;} | acum1=falseToken()
    {return acum1;}
}

void lbrace():{} {
    <LBRACE>
    {
        jjtThis.value="{";
    }
}


public void rbrace():{} {
    <RBRACE>
    {
        jjtThis.value="}";
    }
}

public void lbracket():{} {
    <LBRACKET>
    {
        jjtThis.value="[";
    }
}

public void rbracket():{} {
    <RBRACKET>
    {
        jjtThis.value="]";
    }
}

public void lparen():{} {
    <LPAREN>
    {
        jjtThis.value="(";
    }
}

public void rparen():{} {
    <RPAREN>
    {
        jjtThis.value=")";
    }
}

public void semicolon():{} {
    <SEMICOLON>
    {
        jjtThis.value=";";
    }
}

public void comma():{} {
    <COMMA>
    {
        jjtThis.value=",";
    }
}

public void assign():{} {
    <ASSIGN>
    {
        jjtThis.value="=";
    }
}

public void or():{} {
    <OR>
    {
        jjtThis.value="or";
    }
}

public void and():{} {
    <AND>
    {
        jjtThis.value="and";
    }
}

public String eq():{} {
    <EQ>
    {
        jjtThis.value="==";
        return token.image;
    }
}

public String neq():{} {
    <NEQ>
    {
        jjtThis.value="!=";
        return token.image;
    }
}

public String lt():{} {
    <LT>
    {
        jjtThis.value="<";
        return token.image;
    }
}

public String lte():{} {
    <LTE>
    {
        jjtThis.value="<=";
        return token.image;
    }
}

public String gt():{} {
    <GT>
    {
        jjtThis.value=">";
        return token.image;
    }
}

public String gte():{} {
    <GTE>
    {
        jjtThis.value=">=";
        return token.image;
    }
}

public void plus():{} {
    <PLUS> 
    {
        jjtThis.value="+";
    }
}

public void minus():{} {
    <MINUS> 
    {
        jjtThis.value="-";
    }
}

public void asterisk():{} {
    <ASTERISK>
    {
        jjtThis.value="*";
    }
}

public void slash():{} {
    <SLASH>
    {
        jjtThis.value="/";
    }
}

public void not():{}{
    <NOT>
    {
        jjtThis.value="not";
    }
}

public void ifToken():{} {
    <IF>
    {
        jjtThis.value="if";
    }
}

public void fi():{} {
    <FI>
    {
        jjtThis.value="fi";
    }
}

public void elseToken():{} {
    <ELSE>
    {
        jjtThis.value="else";
    }
}

public void whileToken():{} {
    <WHILE>
    {
        jjtThis.value="while";
    }
}

public void doToken():{} {
    <DO>
    {
        jjtThis.value="do";
    }
}

public void until():{} {
    <UNTIL>
    {
        jjtThis.value="until";
    }
}

public void read():{} {
    <READ>
    {
        jjtThis.value="read";
    }
}

public void write():{} {
    <WRITE>
    {
        jjtThis.value="write";
    }
}

public void breakToken():{} {
    <BREAK>
    {
        jjtThis.value="break";
    }
}

public String intToken():{} {
    <INT> 
    {
        jjtThis.value="int";
        return token.image;
    }
}

public String floatToken():{} {
    <FLOAT> 
    {
        jjtThis.value="float";
        return token.image;
    }
}

public String boolToken():{} {
    <BOOL> 
    {
        jjtThis.value="bool";
        return token.image;
    }
}

public SymbolNode trueToken():{} {
    <TRUE>
    {
        jjtThis.value="true";
        return new SymbolNode("bool", true);
    }
}

public SymbolNode falseToken():{} {
    <FALSE> 
    {
        jjtThis.value="false";
        return new SymbolNode("bool", false);
    }
}

public void then():{} {
    <THEN>
    {
        jjtThis.value="then";
    }
}

public SymbolNode id():{} {
    <ID>
    {
        jjtThis.value="" + token.image;
        return SymTable.GetIndex(token.image);
    }
}

public void idDecl(String type):{} {
    <ID>
    {
        jjtThis.value="" + token.image;
        SymTable.AddIndex(token.image, type);
    }
}

public String idAssign():{} {
    <ID>
    {
        jjtThis.value="" + token.image;
        return token.image;
    }
}

public SymbolNode integer():{} {
    <INTEGER> 
    {
        jjtThis.value="" + token.image;
        return new SymbolNode("int", Integer.parseInt(token.image));
    }
}

public SymbolNode real():{} {
    <REAL>
    {
        jjtThis.value="" + token.image;
        return new SymbolNode("float", Double.parseDouble(token.image));
    }
}